{"version":3,"sources":["../src/scrollspy.ts"],"names":["winHeight","docHeight","items","throttle","callback","idle","setTimeout","getElementPos","item","top","getScrollY","el","getBoundingClientRect","reference","offset","pageYOffset","doc","document","documentElement","clientHeight","body","scrollTop","onResize","onScroll","currentDocHeight","offsetHeight","window","innerHeight","_i","items_1","length","pos","checkVisibleItems","resetElementPosition","currentPos","currentPosOffset","items_2","shift","removeEventListener","param","Error","Object","assign","index","findIndex","i","splice","addEventListener","forEach","border","nodeHtml","createElement","css","join","style","className","setAttribute","appendChild","map"],"mappings":"uMAuBA,IACIA,EACAC,EAFAC,EAAyB,GAsD7B,SAASC,EAASC,GAChB,IAAIC,GAAO,EACX,OAAO,WACDA,IACFD,IACAC,GAAO,EACPC,YAAW,WAAM,OAACD,GAAO,IAAO,OAKtC,SAASE,EAAcC,GACrB,IAAMC,EAAMC,IAEZ,OADoBF,EAAKG,GAAGC,wBACTJ,EAAKK,WAAaJ,EAAMD,EAAKM,OAGlD,SAASJ,IACP,GAA2B,oBAAhBK,YACT,OAAOA,YAEP,IAAIC,EAAMC,SAASC,gBAEnB,OADAF,EAAMA,EAAIG,aAAeH,EAAMC,SAASG,MAC7BC,UAIf,SAASC,KAQT,SAASC,IA4BT,IACQC,EAAAA,EAAmBP,SAASG,KAAKK,aACnCxB,IAAcuB,IAChBvB,EAAYuB,EAhBhB,WACExB,EAAY0B,OAAOC,YACnB,IAAmB,IAAAC,EAAA,EAAAC,EAAA3B,EAAA0B,EAAAC,EAAAC,OAAAF,IAAO,CAArB,IAAMpB,EAAIqB,EAAAD,GACbpB,EAAKuB,IAAMxB,EAAcC,GAE3BwB,IAYEC,IA9BFD,IAkCF,SAASA,IAGP,IAFA,IAAME,EAAaxB,IACbyB,EAAmBnC,EAAYkC,EAClBN,EAAA,EAAAQ,EAAAlC,EAAA0B,EAAAQ,EAAAN,OAAAF,IAAO,CAArB,IAAMpB,EAAI4B,EAAAR,GACb,KAAIO,GAAoB3B,EAAKuB,KAM3B,MALIvB,EAAKJ,UACPI,EAAKJ,WAEPF,EAAMmC,QAKLnC,EAAM4B,SAtCXJ,OAAOY,oBAAoB,SAAUnC,EAASoB,IAC9CG,OAAOY,oBAAoB,SAAUnC,EAASmB,WAzFhD,SAAoBiB,GAClB,IAAKA,EAAM5B,GACT,MAAM,IAAI6B,MAAM,6CAElB,IAAMhC,EAAsBiC,OAAOC,OACjC,CAAE5B,OAAQ,IAAKD,UAAW,MAAOkB,IAAK,GACtCQ,GAEF/B,EAAKuB,IAAMxB,EAAcC,GAEzB,IAAMmC,EAAQzC,EAAM0C,WAAU,SAAAC,GAAK,OAAAA,EAAEd,IAAMvB,EAAKuB,OAEhD7B,EAAM4C,QAAkB,IAAXH,EAAezC,EAAM4B,OAASa,EAAO,EAAGnC,GAEhC,IAAjBN,EAAM4B,SAuFV9B,EAAY0B,OAAOC,YACnB1B,EAAYgB,SAASG,KAAOH,SAASG,KAAKK,aAAe,EAnBzDC,OAAOqB,iBAAiB,SAAU5C,EAASoB,IAC3CG,OAAOqB,iBAAiB,SAAU5C,EAASmB,KAlE3CU,aA1BF,WACE9B,EAAQ,YA4BV,WAkBE,OAjBAA,EAAM8C,SAAQ,SAACxC,EAAMqC,GACnB,IACMI,EAAS,eADDJ,EAAI,EAAI,MAAQ,QAExBK,EAAWjC,SAASkC,cAAc,OAClCC,EAAM,CACV,QAAQ5C,EAAKuB,IAAG,IAChB,eACA,sBACA,eAAekB,EAAM,KACrBI,KAAK,IAEP7C,EAAKG,GAAG2C,MAAML,OAASA,EAEvBC,EAASK,UAAY,aACrBL,EAASM,aAAa,QAASJ,GAC/BnC,SAASG,KAAKqC,YAAYP,MAErBhD,cA3CT,WACE,OAAOA,EAAMwD,KAAI,SAAAb,GAAK,OAAAA","file":"dist/scrollspy.min.js.map","sourcesContent":["/*\n * Copyright (c) 2016, Globo.com (https://github.com/globocom)\n *\n * License: MIT\n */\n\nexport interface ScrollSpyItemOptions {\n  el: HTMLElement;\n  callback: () => void;\n  offset?: number;\n  reference?: ScrollSpyItemReference;\n}\n\nexport type ScrollSpyItemReference = \"top\" | \"bottom\";\n\nexport type ScrollSpyCallback = () => void;\n\nexport interface ScrollSpyItem extends ScrollSpyItemOptions {\n  offset: number;\n  reference: ScrollSpyItemReference;\n  pos: number;\n}\n\nlet items: ScrollSpyItem[] = [];\nlet winHeight: number;\nlet docHeight: number;\n\nexport function clean(): void {\n  items = [];\n}\n\nexport function getItems(): readonly (Readonly<ScrollSpyItem>)[] {\n  return items.map(i => i);\n}\n\nexport function add(param: ScrollSpyItemOptions): void {\n  if (!param.el) {\n    throw new Error(\"[@globocom/scrollspy] item.el is required\");\n  }\n  const item: ScrollSpyItem = Object.assign(\n    { offset: 200, reference: \"top\", pos: 0 },\n    param\n  );\n  item.pos = getElementPos(item);\n\n  const index = items.findIndex(i => i.pos > item.pos);\n\n  items.splice(index === -1 ? items.length : index, 0, item);\n\n  if (items.length === 1) {\n    setDefaultVariables();\n    startListener();\n  }\n  checkVisibleItems();\n}\n\nexport function debug(): ScrollSpyItem[] {\n  items.forEach((item, i) => {\n    const color = i % 2 ? \"red\" : \"blue\";\n    const border = `2px dashed ${color}`;\n    const nodeHtml = document.createElement(\"div\");\n    const css = [\n      `top: ${item.pos};`,\n      \"width: 100%;\",\n      \"position: absolute;\",\n      `border-top: ${border};`\n    ].join(\"\");\n\n    item.el.style.border = border;\n\n    nodeHtml.className = \"debug-line\";\n    nodeHtml.setAttribute(\"style\", css);\n    document.body.appendChild(nodeHtml);\n  });\n  return items;\n}\n\nfunction throttle(callback: ScrollSpyCallback): () => void {\n  let idle = true;\n  return () => {\n    if (idle) {\n      callback();\n      idle = false;\n      setTimeout(() => (idle = true), 150);\n    }\n  };\n}\n\nfunction getElementPos(item: ScrollSpyItem): number {\n  const top = getScrollY();\n  const boundClient = item.el.getBoundingClientRect();\n  return boundClient[item.reference] + top - item.offset;\n}\n\nfunction getScrollY(): number {\n  if (typeof pageYOffset !== \"undefined\") {\n    return pageYOffset;\n  } else {\n    let doc = document.documentElement;\n    doc = doc.clientHeight ? doc : document.body;\n    return doc.scrollTop;\n  }\n}\n\nfunction onResize(): void {\n  throttle(() => {\n    if (winHeight !== window.innerHeight) {\n      resetElementPosition();\n    }\n  });\n}\n\nfunction onScroll(): void {\n  checkDocumentHeight();\n  checkVisibleItems();\n}\n\nfunction startListener(): void {\n  window.addEventListener(\"scroll\", throttle(onScroll));\n  window.addEventListener(\"resize\", throttle(onResize));\n}\n\nfunction stopListeners(): void {\n  window.removeEventListener(\"scroll\", throttle(onScroll));\n  window.removeEventListener(\"resize\", throttle(onResize));\n}\n\nfunction resetElementPosition(): void {\n  winHeight = window.innerHeight;\n  for (const item of items) {\n    item.pos = getElementPos(item);\n  }\n  checkVisibleItems();\n}\n\nfunction setDefaultVariables(): void {\n  winHeight = window.innerHeight;\n  docHeight = document.body ? document.body.offsetHeight : 0;\n}\n\nfunction checkDocumentHeight(): void {\n  const currentDocHeight = document.body.offsetHeight;\n  if (docHeight !== currentDocHeight) {\n    docHeight = currentDocHeight;\n    resetElementPosition();\n  }\n}\n\nfunction checkVisibleItems(): void {\n  const currentPos = getScrollY();\n  const currentPosOffset = winHeight + currentPos;\n  for (const item of items) {\n    if (currentPosOffset >= item.pos) {\n      if (item.callback) {\n        item.callback();\n      }\n      items.shift();\n    } else {\n      break;\n    }\n  }\n  if (!items.length) {\n    stopListeners();\n  }\n}\n"]}